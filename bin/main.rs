// Copyright 2017 Lyndon Brown
//
// Licensed under the MIT license or the Apache license (version 2.0), at your option. You may not
// copy, modify, or distribute this file except in compliance with said license. You can find copies
// of these licenses either in the LICENSE-MIT and LICENSE-APACHE files, or alternatively at
// <http://opensource.org/licenses/MIT> and <http://www.apache.org/licenses/LICENSE-2.0>
// respectively.

//! Test program for the `gong` library
//!
//! This test program takes user supplied command args, parses them with the library against a
//! set of example available options, and outputs a description of the results generated by the
//! parsing library.
//!
//! The analysis is output in color, where supported and applicable.
//!
//! See the `README.md` file for instructions.

#![doc(html_logo_url = "https://github.com/jnqnfe/gong/raw/master/logo.png",
       html_favicon_url = "https://github.com/jnqnfe/gong/raw/master/favicon.ico")]
#![doc(html_no_source)]

extern crate gong;
extern crate term_ctrl;

use std::ffi::OsStr;
use term_ctrl::predefined::*;
use gong::{longopt, shortopt, option_set};
use gong::analysis::{Item, ProblemItem, DataLocation};
use gong::options::OptionType;
use gong::parser::{Parser, OptionsMode};
use gong::positionals::Policy as PositionalsPolicy;

const COL_HEADER: &str = combinations::fg_bold::MAGENTA;
const COL_O: &str = colours::fg::GREEN;  //okay
const COL_E: &str = colours::fg::RED;    //error
const COL_CHAR: &str = colours::fg::bright::BLUE;
const COL_MODE: &str = colours::fg::bright::BLUE;
const COL_DATA: &str = colours::fg::bright::YELLOW;

/// Config: Used for holding state of stdout formatting support
pub mod config {
    use std::sync::Once;
    use term_ctrl::support::use_fmt_stdout;

    static mut FORMATTED_STDOUT: bool = false;
    static INIT: Once = Once::new();

    pub fn init() {
        unsafe {
            INIT.call_once(|| {
                FORMATTED_STDOUT = use_fmt_stdout(cfg!(feature = "color"));
            });
        }
    }

    pub fn formatted_stdout() -> bool {
        unsafe { FORMATTED_STDOUT }
    }
}

// Color? Filter the provided “formatted-stdout-ctrl-seq” string
macro_rules! c {
    ( $code:expr ) => { if config::formatted_stdout() { $code } else { "" } };
}

fn main() {
    config::init();

    #[cfg(not(feature = "pos_policy2"))]
    const POSITIONALS_POLICY: PositionalsPolicy = PositionalsPolicy::Max(2);
    #[cfg(feature = "pos_policy2")]
    const POSITIONALS_POLICY: PositionalsPolicy = PositionalsPolicy::Min(2);

    // Set up valid option descriptions
    let opts = option_set!(
        @long [
            longopt!(@flag "help"),
            longopt!(@flag "foo"),
            longopt!(@flag "version"),
            longopt!(@flag "foobar"),
            longopt!(@data "hah"),
            longopt!(@flag "ábc"),
            longopt!(@mixed "delay"),
        ],
        @short [
            shortopt!(@flag 'h'),
            shortopt!(@flag '❤'),
            shortopt!(@flag 'x'),
            shortopt!(@data 'o'),
            shortopt!(@mixed 'p'),
            shortopt!(@mixed '💧'),
            shortopt!(@data 'Ɛ'),
        ]
    );
    let mut parser = Parser::new(&opts);
    parser.set_positionals_policy(POSITIONALS_POLICY);

    match cfg!(feature = "alt_mode") {
        true => { parser.settings().set_mode(OptionsMode::Alternate); },
        false => { parser.settings().set_mode(OptionsMode::Standard); },
    }
    parser.settings().set_allow_opt_abbreviations(!cfg!(feature = "no_opt_abbreviations"))
                     .set_posixly_correct(cfg!(feature = "posixly_correct"))
                     .set_stop_on_problem(!cfg!(feature = "no_stop_on_problem"));

    debug_assert!(parser.is_valid());

    println!("\n[ {}Config{} ]\n", c!(COL_HEADER), c!(RESET));

    #[cfg(not(feature = "alt_mode"))]
    println!("Option style: {}Standard{}", c!(COL_MODE), c!(RESET));
    #[cfg(feature = "alt_mode")]
    println!("Option style: {}Alternate{}", c!(COL_MODE), c!(RESET));

    #[cfg(not(feature = "posixly_correct"))]
    println!("Posixly correct?: {}No{}", c!(COL_MODE), c!(RESET));
    #[cfg(feature = "posixly_correct")]
    println!("Posixly correct?: {}Yes{}", c!(COL_MODE), c!(RESET));

    #[cfg(not(feature = "keep_prog_name"))]
    println!("Skip first argument (program name): {}true{}", c!(COL_MODE), c!(RESET));
    #[cfg(feature = "keep_prog_name")]
    println!("Skip first argument (program name): {}false{}", c!(COL_MODE), c!(RESET));

    #[cfg(not(feature = "no_opt_abbreviations"))]
    println!("Abbreviated option name matching: {}on{}", c!(COL_MODE), c!(RESET));
    #[cfg(feature = "no_opt_abbreviations")]
    println!("Abbreviated option name matching: {}off{}", c!(COL_MODE), c!(RESET));

    #[cfg(not(feature = "no_stop_on_problem"))]
    println!("Stop parsing upon problem: {}on{}", c!(COL_MODE), c!(RESET));
    #[cfg(feature = "no_stop_on_problem")]
    println!("Stop parsing upon problem: {}off{}", c!(COL_MODE), c!(RESET));

    println!("Positionals policy: {}{:?}{}", c!(COL_MODE), POSITIONALS_POLICY, c!(RESET));

    println!("\nCompile with different features to change the config!\n");

    println!("[ {}Test conditions{} ]\n", c!(COL_HEADER), c!(RESET));

    println!("Positionals policy: {:?}", POSITIONALS_POLICY);

    println!("Available options:");

    for item in opts.long {
        match item.opt_type {
            OptionType::Flag => println!("    LONG {}", item.name),
            OptionType::Data => println!("    LONG {} {}[Data-taking]{}", item.name, c!(COL_DATA), c!(RESET)),
            OptionType::Mixed => println!("    LONG {} {}[Mixed]{}", item.name, c!(COL_DATA), c!(RESET)),
        }
    }
    for item in opts.short {
        match item.opt_type {
            OptionType::Flag => println!("    SHORT {}", desc_char(item.ch)),
            OptionType::Data => println!("    SHORT {} {}[Data-taking]{}", desc_char(item.ch), c!(COL_DATA), c!(RESET)),
            OptionType::Mixed => println!("    SHORT {} {}[Mixed]{}", desc_char(item.ch), c!(COL_DATA), c!(RESET)),
        }
    }

    #[cfg(feature = "alt_mode")]
    println!("Note: Short options will be ignored in `alternative` mode. They are still printed \
              so you can test and see this is so!");

    println!("Available commands:");
    println!("    None!\n");

    #[cfg(feature = "keep_prog_name")]
    let args: Vec<_> = std::env::args_os().collect();
    #[cfg(not(feature = "keep_prog_name"))]
    let args: Vec<_> = std::env::args_os().skip(1).collect();

    println!("[ {}Your input arguments{} ]\n", c!(COL_HEADER), c!(RESET));

    match args.len() {
        0 => println!("None!"),
        _ => for (i, arg) in args.iter().enumerate() {
            println!("[{}]: {:?}", i, arg);
        },
    }

    let mut iter = parser.parse_iter(&args[..]).indexed();
    let mut problems = false;
    let mut count_zero = true;

    println!("\n[ {}Analysis{} ]\n", c!(COL_HEADER), c!(RESET));

    while let Some((i, item, l)) = iter.next() {
        let printer = match item {
            Ok(_) => print_arg_ok,
            Err(_) => {
                problems = true;
                print_arg_err
            },
        };
        count_zero = false;
        match item {
            Ok(Item::Positional(s)) => printer(i, "Positional", s),
            Ok(Item::EarlyTerminator) => printer(i, "EarlyTerminator", OsStr::new("")),
            Ok(Item::Long(n, None)) => {
                match l.is_none() {
                    true => printer(i, "Long", OsStr::new(&n)),
                    false => {
                        printer(i, "LongWithoutData", OsStr::new(&n));
                        print_data(l.unwrap(), None);
                    },
                }
            },
            Ok(Item::Long(n, Some(d))) => {
                printer(i, "LongWithData", OsStr::new(&n));
                print_data(l.unwrap(), Some(d));
            },
            Err(ProblemItem::UnexpectedPositional(s)) => printer(i, "UnexpectedPositional", s),
            Err(ProblemItem::MissingPositionals(q)) => {
                print_arg_na_err("MissingPositionals");
                println!("    quantity: {}", q)
            },
            Err(ProblemItem::LongMissingData(n)) => printer(i, "LongMissingData", OsStr::new(&n)),
            Err(ProblemItem::LongWithUnexpectedData(n, d)) => {
                printer(i, "LongWithUnexpectedData", OsStr::new(&n));
                println!("    data: {:?}", d)
            },
            Err(ProblemItem::AmbiguousLong(n)) => printer(i, "AmbiguousLong", n),
            Err(ProblemItem::AmbiguousCmd(n)) => printer(i, "AmbiguousCmd", n),
            Err(ProblemItem::UnknownLong(n)) => printer(i, "UnknownLong", OsStr::new(&n)),
            Ok(Item::Short(c, None)) => {
                let desc = desc_char(c);
                match l.is_none() {
                    true => printer(i, "Short", OsStr::new(&desc)),
                    false => {
                        printer(i, "ShortWithoutData", OsStr::new(&desc));
                        print_data(l.unwrap(), None);
                    },
                }
            },
            Ok(Item::Short(c, Some(d))) => {
                let desc = desc_char(c);
                printer(i, "ShortWithData", OsStr::new(&desc));
                print_data(l.unwrap(), Some(d));
            },
            Err(ProblemItem::ShortMissingData(c)) => {
                let desc = desc_char(c);
                printer(i, "ShortMissingData", OsStr::new(&desc));
            },
            Err(ProblemItem::UnknownShort(c)) => {
                let desc = desc_char(c);
                printer(i, "UnknownShort", OsStr::new(&desc));
            },
            Ok(Item::Command(n)) => printer(i, "Command", OsStr::new(&n)),
            Err(ProblemItem::UnknownCommand(n)) => printer(i, "UnknownCommand", OsStr::new(&n)),
        }
    }
    if !count_zero {
        println!();
    }
    else {
        println!("No arguments given!\n");
    }

    #[cfg(not(feature = "no_stop_on_problem"))] {
        if problems {
            println!("Problem found, stopped early!\n");
        }
    }

    match problems {
        true => { println!("Problems: {}true{}\n", c!(COL_E), c!(RESET)); },
        false => {
            println!("Problems: {}false{}\n", c!(COL_O), c!(RESET));
        },
    }
}

fn print_arg(col: &str, index: usize, ty: &str, desc: &str) {
    println!("[arg {}] {}{}{}: {}", index, col, ty, c!(RESET), desc)
}

fn print_arg_na_err(ty: &str) {
    println!("[arg _] {}{}{}:", c!(COL_E), ty, c!(RESET))
}

fn print_arg_ok(index: usize, ty: &str, desc: &OsStr) {
    print_arg(c!(COL_O), index, ty, &desc.to_string_lossy());
}

fn print_arg_err(index: usize, ty: &str, desc: &OsStr) {
    print_arg(c!(COL_E), index, ty, &desc.to_string_lossy());
}

fn desc_char(ch: char) -> String {
    format!("{} {}({}){}", ch, c!(COL_CHAR), ch.escape_unicode(), c!(RESET))
}

fn print_data(loc: DataLocation, data: Option<&OsStr>) {
    match loc {
        DataLocation::SameArg =>
            println!("    {}data from SAME arg!{}", c!(effects::ITALIC), c!(RESET)),
        DataLocation::NextArg =>
            println!("    {}data from NEXT arg!{}", c!(effects::ITALIC), c!(RESET)),
    }
    match data {
        Some(d) => match d.is_empty() {
            true => println!("    {}empty-data{}", c!(effects::ITALIC), c!(RESET)),
            false => println!("    data: {:?}", d),
        },
        None => println!("    {}no-data{}", c!(effects::ITALIC), c!(RESET)),
    }
}
